/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: rpc.proto
 *
 */

/*
 * Copyright 2018, gRPC Authors All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import Foundation
import Dispatch
import gRPC
import SwiftProtobuf

/// Type for errors thrown from generated client code.
internal enum Lnrpc_WalletUnlockerClientError : Error {
  case endOfStream
  case invalidMessageReceived
  case error(c: CallResult)
}

/// CreateWallet (Unary)
internal final class Lnrpc_WalletUnlockerCreateWalletCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.WalletUnlocker/CreateWallet")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_WalletUnlockerClientError` if receives no response.
  fileprivate func run(request: Lnrpc_CreateWalletRequest,
                       metadata: Metadata) throws -> Lnrpc_CreateWalletResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_CreateWalletResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_WalletUnlockerClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_CreateWalletRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_CreateWalletResponse?, CallResult)->())
    throws -> Lnrpc_WalletUnlockerCreateWalletCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_CreateWalletResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// UnlockWallet (Unary)
internal final class Lnrpc_WalletUnlockerUnlockWalletCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.WalletUnlocker/UnlockWallet")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_WalletUnlockerClientError` if receives no response.
  fileprivate func run(request: Lnrpc_UnlockWalletRequest,
                       metadata: Metadata) throws -> Lnrpc_UnlockWalletResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_UnlockWalletResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_WalletUnlockerClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_UnlockWalletRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_UnlockWalletResponse?, CallResult)->())
    throws -> Lnrpc_WalletUnlockerUnlockWalletCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_UnlockWalletResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// Call methods of this class to make API calls.
internal final class Lnrpc_WalletUnlockerService {
  public var channel: Channel

  /// This metadata will be sent with all requests.
  internal var metadata : Metadata

  /// This property allows the service host name to be overridden.
  /// For example, it can be used to make calls to "localhost:8080"
  /// appear to be to "example.com".
  internal var host : String {
    get {
      return self.channel.host
    }
    set {
      self.channel.host = newValue
    }
  }

  /// Create a client.
  internal init(address: String, secure: Bool = true) {
    gRPC.initialize()
    channel = Channel(address:address, secure:secure)
    metadata = Metadata()
  }

  /// Create a client that makes secure connections with a custom certificate and (optional) hostname.
  internal init(address: String, certificates: String, host: String?) {
    gRPC.initialize()
    channel = Channel(address:address, certificates:certificates, host:host)
    metadata = Metadata()
  }

  /// Synchronous. Unary.
  internal func createwallet(_ request: Lnrpc_CreateWalletRequest)
    throws
    -> Lnrpc_CreateWalletResponse {
      return try Lnrpc_WalletUnlockerCreateWalletCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func createwallet(_ request: Lnrpc_CreateWalletRequest,
                  completion: @escaping (Lnrpc_CreateWalletResponse?, CallResult)->())
    throws
    -> Lnrpc_WalletUnlockerCreateWalletCall {
      return try Lnrpc_WalletUnlockerCreateWalletCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func unlockwallet(_ request: Lnrpc_UnlockWalletRequest)
    throws
    -> Lnrpc_UnlockWalletResponse {
      return try Lnrpc_WalletUnlockerUnlockWalletCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func unlockwallet(_ request: Lnrpc_UnlockWalletRequest,
                  completion: @escaping (Lnrpc_UnlockWalletResponse?, CallResult)->())
    throws
    -> Lnrpc_WalletUnlockerUnlockWalletCall {
      return try Lnrpc_WalletUnlockerUnlockWalletCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
}

/// Type for errors thrown from generated client code.
internal enum Lnrpc_LightningClientError : Error {
  case endOfStream
  case invalidMessageReceived
  case error(c: CallResult)
}

/// WalletBalance (Unary)
internal final class Lnrpc_LightningWalletBalanceCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/WalletBalance")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_WalletBalanceRequest,
                       metadata: Metadata) throws -> Lnrpc_WalletBalanceResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_WalletBalanceResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_WalletBalanceRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_WalletBalanceResponse?, CallResult)->())
    throws -> Lnrpc_LightningWalletBalanceCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_WalletBalanceResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// ChannelBalance (Unary)
internal final class Lnrpc_LightningChannelBalanceCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/ChannelBalance")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_ChannelBalanceRequest,
                       metadata: Metadata) throws -> Lnrpc_ChannelBalanceResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_ChannelBalanceResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_ChannelBalanceRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_ChannelBalanceResponse?, CallResult)->())
    throws -> Lnrpc_LightningChannelBalanceCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_ChannelBalanceResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// GetTransactions (Unary)
internal final class Lnrpc_LightningGetTransactionsCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/GetTransactions")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_GetTransactionsRequest,
                       metadata: Metadata) throws -> Lnrpc_TransactionDetails {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_TransactionDetails?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_GetTransactionsRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_TransactionDetails?, CallResult)->())
    throws -> Lnrpc_LightningGetTransactionsCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_TransactionDetails(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// SendCoins (Unary)
internal final class Lnrpc_LightningSendCoinsCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/SendCoins")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_SendCoinsRequest,
                       metadata: Metadata) throws -> Lnrpc_SendCoinsResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_SendCoinsResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_SendCoinsRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_SendCoinsResponse?, CallResult)->())
    throws -> Lnrpc_LightningSendCoinsCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_SendCoinsResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// SubscribeTransactions (Server Streaming)
internal final class Lnrpc_LightningSubscribeTransactionsCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/SubscribeTransactions")
  }

  /// Call this once with the message to send. Nonblocking.
  fileprivate func start(request: Lnrpc_GetTransactionsRequest,
                         metadata: Metadata,
                         completion: @escaping (CallResult) -> ())
    throws -> Lnrpc_LightningSubscribeTransactionsCall {
      let requestData = try request.serializedData()
      try call.start(.serverStreaming,
                     metadata:metadata,
                     message:requestData,
                     completion:completion)
      return self
  }

  /// Call this to wait for a result. Blocking.
  internal func receive() throws -> Lnrpc_Transaction {
    var returnError : Lnrpc_LightningClientError?
    var returnResponse : Lnrpc_Transaction!
    let sem = DispatchSemaphore(value: 0)
    do {
      try receive() {response, error in
        returnResponse = response
        returnError = error
        sem.signal()
      }
      _ = sem.wait(timeout: DispatchTime.distantFuture)
    }
    if let returnError = returnError {
      throw returnError
    }
    return returnResponse
  }

  /// Call this to wait for a result. Nonblocking.
  internal func receive(completion:@escaping (Lnrpc_Transaction?, Lnrpc_LightningClientError?)->()) throws {
    do {
      try call.receiveMessage() {(responseData) in
        if let responseData = responseData {
          if let response = try? Lnrpc_Transaction(serializedData:responseData) {
            completion(response, nil)
          } else {
            completion(nil, Lnrpc_LightningClientError.invalidMessageReceived)
          }
        } else {
          completion(nil, Lnrpc_LightningClientError.endOfStream)
        }
      }
    }
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// SendMany (Unary)
internal final class Lnrpc_LightningSendManyCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/SendMany")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_SendManyRequest,
                       metadata: Metadata) throws -> Lnrpc_SendManyResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_SendManyResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_SendManyRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_SendManyResponse?, CallResult)->())
    throws -> Lnrpc_LightningSendManyCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_SendManyResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// NewAddress (Unary)
internal final class Lnrpc_LightningNewAddressCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/NewAddress")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_NewAddressRequest,
                       metadata: Metadata) throws -> Lnrpc_NewAddressResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_NewAddressResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_NewAddressRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_NewAddressResponse?, CallResult)->())
    throws -> Lnrpc_LightningNewAddressCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_NewAddressResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// NewWitnessAddress (Unary)
internal final class Lnrpc_LightningNewWitnessAddressCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/NewWitnessAddress")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_NewWitnessAddressRequest,
                       metadata: Metadata) throws -> Lnrpc_NewAddressResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_NewAddressResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_NewWitnessAddressRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_NewAddressResponse?, CallResult)->())
    throws -> Lnrpc_LightningNewWitnessAddressCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_NewAddressResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// SignMessage (Unary)
internal final class Lnrpc_LightningSignMessageCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/SignMessage")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_SignMessageRequest,
                       metadata: Metadata) throws -> Lnrpc_SignMessageResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_SignMessageResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_SignMessageRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_SignMessageResponse?, CallResult)->())
    throws -> Lnrpc_LightningSignMessageCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_SignMessageResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// VerifyMessage (Unary)
internal final class Lnrpc_LightningVerifyMessageCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/VerifyMessage")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_VerifyMessageRequest,
                       metadata: Metadata) throws -> Lnrpc_VerifyMessageResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_VerifyMessageResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_VerifyMessageRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_VerifyMessageResponse?, CallResult)->())
    throws -> Lnrpc_LightningVerifyMessageCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_VerifyMessageResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// ConnectPeer (Unary)
internal final class Lnrpc_LightningConnectPeerCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/ConnectPeer")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_ConnectPeerRequest,
                       metadata: Metadata) throws -> Lnrpc_ConnectPeerResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_ConnectPeerResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_ConnectPeerRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_ConnectPeerResponse?, CallResult)->())
    throws -> Lnrpc_LightningConnectPeerCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_ConnectPeerResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// DisconnectPeer (Unary)
internal final class Lnrpc_LightningDisconnectPeerCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/DisconnectPeer")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_DisconnectPeerRequest,
                       metadata: Metadata) throws -> Lnrpc_DisconnectPeerResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_DisconnectPeerResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_DisconnectPeerRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_DisconnectPeerResponse?, CallResult)->())
    throws -> Lnrpc_LightningDisconnectPeerCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_DisconnectPeerResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// ListPeers (Unary)
internal final class Lnrpc_LightningListPeersCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/ListPeers")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_ListPeersRequest,
                       metadata: Metadata) throws -> Lnrpc_ListPeersResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_ListPeersResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_ListPeersRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_ListPeersResponse?, CallResult)->())
    throws -> Lnrpc_LightningListPeersCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_ListPeersResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// GetInfo (Unary)
internal final class Lnrpc_LightningGetInfoCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/GetInfo")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_GetInfoRequest,
                       metadata: Metadata) throws -> Lnrpc_GetInfoResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_GetInfoResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_GetInfoRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_GetInfoResponse?, CallResult)->())
    throws -> Lnrpc_LightningGetInfoCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_GetInfoResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// PendingChannels (Unary)
internal final class Lnrpc_LightningPendingChannelsCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/PendingChannels")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_PendingChannelsRequest,
                       metadata: Metadata) throws -> Lnrpc_PendingChannelsResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_PendingChannelsResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_PendingChannelsRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_PendingChannelsResponse?, CallResult)->())
    throws -> Lnrpc_LightningPendingChannelsCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_PendingChannelsResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// ListChannels (Unary)
internal final class Lnrpc_LightningListChannelsCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/ListChannels")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_ListChannelsRequest,
                       metadata: Metadata) throws -> Lnrpc_ListChannelsResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_ListChannelsResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_ListChannelsRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_ListChannelsResponse?, CallResult)->())
    throws -> Lnrpc_LightningListChannelsCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_ListChannelsResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// OpenChannelSync (Unary)
internal final class Lnrpc_LightningOpenChannelSyncCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/OpenChannelSync")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_OpenChannelRequest,
                       metadata: Metadata) throws -> Lnrpc_ChannelPoint {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_ChannelPoint?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_OpenChannelRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_ChannelPoint?, CallResult)->())
    throws -> Lnrpc_LightningOpenChannelSyncCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_ChannelPoint(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// OpenChannel (Server Streaming)
internal final class Lnrpc_LightningOpenChannelCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/OpenChannel")
  }

  /// Call this once with the message to send. Nonblocking.
  fileprivate func start(request: Lnrpc_OpenChannelRequest,
                         metadata: Metadata,
                         completion: @escaping (CallResult) -> ())
    throws -> Lnrpc_LightningOpenChannelCall {
      let requestData = try request.serializedData()
      try call.start(.serverStreaming,
                     metadata:metadata,
                     message:requestData,
                     completion:completion)
      return self
  }

  /// Call this to wait for a result. Blocking.
  internal func receive() throws -> Lnrpc_OpenStatusUpdate {
    var returnError : Lnrpc_LightningClientError?
    var returnResponse : Lnrpc_OpenStatusUpdate!
    let sem = DispatchSemaphore(value: 0)
    do {
      try receive() {response, error in
        returnResponse = response
        returnError = error
        sem.signal()
      }
      _ = sem.wait(timeout: DispatchTime.distantFuture)
    }
    if let returnError = returnError {
      throw returnError
    }
    return returnResponse
  }

  /// Call this to wait for a result. Nonblocking.
  internal func receive(completion:@escaping (Lnrpc_OpenStatusUpdate?, Lnrpc_LightningClientError?)->()) throws {
    do {
      try call.receiveMessage() {(responseData) in
        if let responseData = responseData {
          if let response = try? Lnrpc_OpenStatusUpdate(serializedData:responseData) {
            completion(response, nil)
          } else {
            completion(nil, Lnrpc_LightningClientError.invalidMessageReceived)
          }
        } else {
          completion(nil, Lnrpc_LightningClientError.endOfStream)
        }
      }
    }
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// CloseChannel (Server Streaming)
internal final class Lnrpc_LightningCloseChannelCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/CloseChannel")
  }

  /// Call this once with the message to send. Nonblocking.
  fileprivate func start(request: Lnrpc_CloseChannelRequest,
                         metadata: Metadata,
                         completion: @escaping (CallResult) -> ())
    throws -> Lnrpc_LightningCloseChannelCall {
      let requestData = try request.serializedData()
      try call.start(.serverStreaming,
                     metadata:metadata,
                     message:requestData,
                     completion:completion)
      return self
  }

  /// Call this to wait for a result. Blocking.
  internal func receive() throws -> Lnrpc_CloseStatusUpdate {
    var returnError : Lnrpc_LightningClientError?
    var returnResponse : Lnrpc_CloseStatusUpdate!
    let sem = DispatchSemaphore(value: 0)
    do {
      try receive() {response, error in
        returnResponse = response
        returnError = error
        sem.signal()
      }
      _ = sem.wait(timeout: DispatchTime.distantFuture)
    }
    if let returnError = returnError {
      throw returnError
    }
    return returnResponse
  }

  /// Call this to wait for a result. Nonblocking.
  internal func receive(completion:@escaping (Lnrpc_CloseStatusUpdate?, Lnrpc_LightningClientError?)->()) throws {
    do {
      try call.receiveMessage() {(responseData) in
        if let responseData = responseData {
          if let response = try? Lnrpc_CloseStatusUpdate(serializedData:responseData) {
            completion(response, nil)
          } else {
            completion(nil, Lnrpc_LightningClientError.invalidMessageReceived)
          }
        } else {
          completion(nil, Lnrpc_LightningClientError.endOfStream)
        }
      }
    }
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// SendPayment (Bidirectional Streaming)
internal final class Lnrpc_LightningSendPaymentCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/SendPayment")
  }

  /// Call this to start a call. Nonblocking.
  fileprivate func start(metadata:Metadata, completion:@escaping (CallResult)->())
    throws -> Lnrpc_LightningSendPaymentCall {
      try self.call.start(.bidiStreaming, metadata:metadata, completion:completion)
      return self
  }

  /// Call this to wait for a result. Blocking.
  internal func receive() throws -> Lnrpc_SendResponse {
    var returnError : Lnrpc_LightningClientError?
    var returnMessage : Lnrpc_SendResponse!
    let sem = DispatchSemaphore(value: 0)
    do {
      try receive() {response, error in
        returnMessage = response
        returnError = error
        sem.signal()
      }
      _ = sem.wait(timeout: DispatchTime.distantFuture)
    }
    if let returnError = returnError {
      throw returnError
    }
    return returnMessage
  }

  /// Call this to wait for a result. Nonblocking.
  internal func receive(completion:@escaping (Lnrpc_SendResponse?, Lnrpc_LightningClientError?)->()) throws {
    do {
      try call.receiveMessage() {(data) in
        if let data = data {
          if let returnMessage = try? Lnrpc_SendResponse(serializedData:data) {
            completion(returnMessage, nil)
          } else {
            completion(nil, Lnrpc_LightningClientError.invalidMessageReceived)
          }
        } else {
          completion(nil, Lnrpc_LightningClientError.endOfStream)
        }
      }
    }
  }

  /// Call this to send each message in the request stream.
  internal func send(_ message:Lnrpc_SendRequest, errorHandler:@escaping (Error)->()) throws {
    let messageData = try message.serializedData()
    try call.sendMessage(data:messageData, errorHandler:errorHandler)
  }

  /// Call this to close the sending connection. Blocking.
  internal func closeSend() throws {
    let sem = DispatchSemaphore(value: 0)
    try closeSend() {
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
  }

  /// Call this to close the sending connection. Nonblocking.
  internal func closeSend(completion:@escaping ()->()) throws {
    try call.close() {
      completion()
    }
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// SendPaymentSync (Unary)
internal final class Lnrpc_LightningSendPaymentSyncCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/SendPaymentSync")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_SendRequest,
                       metadata: Metadata) throws -> Lnrpc_SendResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_SendResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_SendRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_SendResponse?, CallResult)->())
    throws -> Lnrpc_LightningSendPaymentSyncCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_SendResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// AddInvoice (Unary)
internal final class Lnrpc_LightningAddInvoiceCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/AddInvoice")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_Invoice,
                       metadata: Metadata) throws -> Lnrpc_AddInvoiceResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_AddInvoiceResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_Invoice,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_AddInvoiceResponse?, CallResult)->())
    throws -> Lnrpc_LightningAddInvoiceCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_AddInvoiceResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// ListInvoices (Unary)
internal final class Lnrpc_LightningListInvoicesCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/ListInvoices")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_ListInvoiceRequest,
                       metadata: Metadata) throws -> Lnrpc_ListInvoiceResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_ListInvoiceResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_ListInvoiceRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_ListInvoiceResponse?, CallResult)->())
    throws -> Lnrpc_LightningListInvoicesCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_ListInvoiceResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// LookupInvoice (Unary)
internal final class Lnrpc_LightningLookupInvoiceCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/LookupInvoice")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_PaymentHash,
                       metadata: Metadata) throws -> Lnrpc_Invoice {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_Invoice?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_PaymentHash,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_Invoice?, CallResult)->())
    throws -> Lnrpc_LightningLookupInvoiceCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_Invoice(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// SubscribeInvoices (Server Streaming)
internal final class Lnrpc_LightningSubscribeInvoicesCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/SubscribeInvoices")
  }

  /// Call this once with the message to send. Nonblocking.
  fileprivate func start(request: Lnrpc_InvoiceSubscription,
                         metadata: Metadata,
                         completion: @escaping (CallResult) -> ())
    throws -> Lnrpc_LightningSubscribeInvoicesCall {
      let requestData = try request.serializedData()
      try call.start(.serverStreaming,
                     metadata:metadata,
                     message:requestData,
                     completion:completion)
      return self
  }

  /// Call this to wait for a result. Blocking.
  internal func receive() throws -> Lnrpc_Invoice {
    var returnError : Lnrpc_LightningClientError?
    var returnResponse : Lnrpc_Invoice!
    let sem = DispatchSemaphore(value: 0)
    do {
      try receive() {response, error in
        returnResponse = response
        returnError = error
        sem.signal()
      }
      _ = sem.wait(timeout: DispatchTime.distantFuture)
    }
    if let returnError = returnError {
      throw returnError
    }
    return returnResponse
  }

  /// Call this to wait for a result. Nonblocking.
  internal func receive(completion:@escaping (Lnrpc_Invoice?, Lnrpc_LightningClientError?)->()) throws {
    do {
      try call.receiveMessage() {(responseData) in
        if let responseData = responseData {
          if let response = try? Lnrpc_Invoice(serializedData:responseData) {
            completion(response, nil)
          } else {
            completion(nil, Lnrpc_LightningClientError.invalidMessageReceived)
          }
        } else {
          completion(nil, Lnrpc_LightningClientError.endOfStream)
        }
      }
    }
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// DecodePayReq (Unary)
internal final class Lnrpc_LightningDecodePayReqCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/DecodePayReq")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_PayReqString,
                       metadata: Metadata) throws -> Lnrpc_PayReq {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_PayReq?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_PayReqString,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_PayReq?, CallResult)->())
    throws -> Lnrpc_LightningDecodePayReqCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_PayReq(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// ListPayments (Unary)
internal final class Lnrpc_LightningListPaymentsCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/ListPayments")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_ListPaymentsRequest,
                       metadata: Metadata) throws -> Lnrpc_ListPaymentsResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_ListPaymentsResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_ListPaymentsRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_ListPaymentsResponse?, CallResult)->())
    throws -> Lnrpc_LightningListPaymentsCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_ListPaymentsResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// DeleteAllPayments (Unary)
internal final class Lnrpc_LightningDeleteAllPaymentsCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/DeleteAllPayments")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_DeleteAllPaymentsRequest,
                       metadata: Metadata) throws -> Lnrpc_DeleteAllPaymentsResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_DeleteAllPaymentsResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_DeleteAllPaymentsRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_DeleteAllPaymentsResponse?, CallResult)->())
    throws -> Lnrpc_LightningDeleteAllPaymentsCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_DeleteAllPaymentsResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// DescribeGraph (Unary)
internal final class Lnrpc_LightningDescribeGraphCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/DescribeGraph")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_ChannelGraphRequest,
                       metadata: Metadata) throws -> Lnrpc_ChannelGraph {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_ChannelGraph?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_ChannelGraphRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_ChannelGraph?, CallResult)->())
    throws -> Lnrpc_LightningDescribeGraphCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_ChannelGraph(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// GetChanInfo (Unary)
internal final class Lnrpc_LightningGetChanInfoCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/GetChanInfo")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_ChanInfoRequest,
                       metadata: Metadata) throws -> Lnrpc_ChannelEdge {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_ChannelEdge?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_ChanInfoRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_ChannelEdge?, CallResult)->())
    throws -> Lnrpc_LightningGetChanInfoCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_ChannelEdge(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// GetNodeInfo (Unary)
internal final class Lnrpc_LightningGetNodeInfoCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/GetNodeInfo")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_NodeInfoRequest,
                       metadata: Metadata) throws -> Lnrpc_NodeInfo {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_NodeInfo?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_NodeInfoRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_NodeInfo?, CallResult)->())
    throws -> Lnrpc_LightningGetNodeInfoCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_NodeInfo(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// QueryRoutes (Unary)
internal final class Lnrpc_LightningQueryRoutesCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/QueryRoutes")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_QueryRoutesRequest,
                       metadata: Metadata) throws -> Lnrpc_QueryRoutesResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_QueryRoutesResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_QueryRoutesRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_QueryRoutesResponse?, CallResult)->())
    throws -> Lnrpc_LightningQueryRoutesCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_QueryRoutesResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// GetNetworkInfo (Unary)
internal final class Lnrpc_LightningGetNetworkInfoCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/GetNetworkInfo")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_NetworkInfoRequest,
                       metadata: Metadata) throws -> Lnrpc_NetworkInfo {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_NetworkInfo?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_NetworkInfoRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_NetworkInfo?, CallResult)->())
    throws -> Lnrpc_LightningGetNetworkInfoCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_NetworkInfo(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// StopDaemon (Unary)
internal final class Lnrpc_LightningStopDaemonCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/StopDaemon")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_StopRequest,
                       metadata: Metadata) throws -> Lnrpc_StopResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_StopResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_StopRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_StopResponse?, CallResult)->())
    throws -> Lnrpc_LightningStopDaemonCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_StopResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// SubscribeChannelGraph (Server Streaming)
internal final class Lnrpc_LightningSubscribeChannelGraphCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/SubscribeChannelGraph")
  }

  /// Call this once with the message to send. Nonblocking.
  fileprivate func start(request: Lnrpc_GraphTopologySubscription,
                         metadata: Metadata,
                         completion: @escaping (CallResult) -> ())
    throws -> Lnrpc_LightningSubscribeChannelGraphCall {
      let requestData = try request.serializedData()
      try call.start(.serverStreaming,
                     metadata:metadata,
                     message:requestData,
                     completion:completion)
      return self
  }

  /// Call this to wait for a result. Blocking.
  internal func receive() throws -> Lnrpc_GraphTopologyUpdate {
    var returnError : Lnrpc_LightningClientError?
    var returnResponse : Lnrpc_GraphTopologyUpdate!
    let sem = DispatchSemaphore(value: 0)
    do {
      try receive() {response, error in
        returnResponse = response
        returnError = error
        sem.signal()
      }
      _ = sem.wait(timeout: DispatchTime.distantFuture)
    }
    if let returnError = returnError {
      throw returnError
    }
    return returnResponse
  }

  /// Call this to wait for a result. Nonblocking.
  internal func receive(completion:@escaping (Lnrpc_GraphTopologyUpdate?, Lnrpc_LightningClientError?)->()) throws {
    do {
      try call.receiveMessage() {(responseData) in
        if let responseData = responseData {
          if let response = try? Lnrpc_GraphTopologyUpdate(serializedData:responseData) {
            completion(response, nil)
          } else {
            completion(nil, Lnrpc_LightningClientError.invalidMessageReceived)
          }
        } else {
          completion(nil, Lnrpc_LightningClientError.endOfStream)
        }
      }
    }
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// DebugLevel (Unary)
internal final class Lnrpc_LightningDebugLevelCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/DebugLevel")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_DebugLevelRequest,
                       metadata: Metadata) throws -> Lnrpc_DebugLevelResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_DebugLevelResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_DebugLevelRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_DebugLevelResponse?, CallResult)->())
    throws -> Lnrpc_LightningDebugLevelCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_DebugLevelResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// FeeReport (Unary)
internal final class Lnrpc_LightningFeeReportCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/FeeReport")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_FeeReportRequest,
                       metadata: Metadata) throws -> Lnrpc_FeeReportResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_FeeReportResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_FeeReportRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_FeeReportResponse?, CallResult)->())
    throws -> Lnrpc_LightningFeeReportCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_FeeReportResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// UpdateChannelPolicy (Unary)
internal final class Lnrpc_LightningUpdateChannelPolicyCall {
  private var call : Call

  /// Create a call.
  fileprivate init(_ channel: Channel) {
    self.call = channel.makeCall("/lnrpc.Lightning/UpdateChannelPolicy")
  }

  /// Run the call. Blocks until the reply is received.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call. `Lnrpc_LightningClientError` if receives no response.
  fileprivate func run(request: Lnrpc_PolicyUpdateRequest,
                       metadata: Metadata) throws -> Lnrpc_PolicyUpdateResponse {
    let sem = DispatchSemaphore(value: 0)
    var returnCallResult : CallResult!
    var returnResponse : Lnrpc_PolicyUpdateResponse?
    _ = try start(request:request, metadata:metadata) {response, callResult in
      returnResponse = response
      returnCallResult = callResult
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let returnResponse = returnResponse {
      return returnResponse
    } else {
      throw Lnrpc_LightningClientError.error(c: returnCallResult)
    }
  }

  /// Start the call. Nonblocking.
  /// - Throws: `BinaryEncodingError` if encoding fails. `CallError` if fails to call.
  fileprivate func start(request: Lnrpc_PolicyUpdateRequest,
                         metadata: Metadata,
                         completion: @escaping (Lnrpc_PolicyUpdateResponse?, CallResult)->())
    throws -> Lnrpc_LightningUpdateChannelPolicyCall {

      let requestData = try request.serializedData()
      try call.start(.unary,
                     metadata:metadata,
                     message:requestData)
      {(callResult) in
        if let responseData = callResult.resultData,
          let response = try? Lnrpc_PolicyUpdateResponse(serializedData:responseData) {
          completion(response, callResult)
        } else {
          completion(nil, callResult)
        }
      }
      return self
  }

  /// Cancel the call.
  internal func cancel() {
    call.cancel()
  }
}

/// Call methods of this class to make API calls.
internal final class Lnrpc_LightningService {
  public var channel: Channel

  /// This metadata will be sent with all requests.
  internal var metadata : Metadata

  /// This property allows the service host name to be overridden.
  /// For example, it can be used to make calls to "localhost:8080"
  /// appear to be to "example.com".
  internal var host : String {
    get {
      return self.channel.host
    }
    set {
      self.channel.host = newValue
    }
  }

  /// Create a client.
  internal init(address: String, secure: Bool = true) {
    gRPC.initialize()
    channel = Channel(address:address, secure:secure)
    metadata = Metadata()
  }

  /// Create a client that makes secure connections with a custom certificate and (optional) hostname.
  internal init(address: String, certificates: String, host: String?) {
    gRPC.initialize()
    channel = Channel(address:address, certificates:certificates, host:host)
    metadata = Metadata()
  }

  /// Synchronous. Unary.
  internal func walletbalance(_ request: Lnrpc_WalletBalanceRequest)
    throws
    -> Lnrpc_WalletBalanceResponse {
      return try Lnrpc_LightningWalletBalanceCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func walletbalance(_ request: Lnrpc_WalletBalanceRequest,
                  completion: @escaping (Lnrpc_WalletBalanceResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningWalletBalanceCall {
      return try Lnrpc_LightningWalletBalanceCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func channelbalance(_ request: Lnrpc_ChannelBalanceRequest)
    throws
    -> Lnrpc_ChannelBalanceResponse {
      return try Lnrpc_LightningChannelBalanceCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func channelbalance(_ request: Lnrpc_ChannelBalanceRequest,
                  completion: @escaping (Lnrpc_ChannelBalanceResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningChannelBalanceCall {
      return try Lnrpc_LightningChannelBalanceCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func gettransactions(_ request: Lnrpc_GetTransactionsRequest)
    throws
    -> Lnrpc_TransactionDetails {
      return try Lnrpc_LightningGetTransactionsCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func gettransactions(_ request: Lnrpc_GetTransactionsRequest,
                  completion: @escaping (Lnrpc_TransactionDetails?, CallResult)->())
    throws
    -> Lnrpc_LightningGetTransactionsCall {
      return try Lnrpc_LightningGetTransactionsCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func sendcoins(_ request: Lnrpc_SendCoinsRequest)
    throws
    -> Lnrpc_SendCoinsResponse {
      return try Lnrpc_LightningSendCoinsCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func sendcoins(_ request: Lnrpc_SendCoinsRequest,
                  completion: @escaping (Lnrpc_SendCoinsResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningSendCoinsCall {
      return try Lnrpc_LightningSendCoinsCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  internal func subscribetransactions(_ request: Lnrpc_GetTransactionsRequest, completion: @escaping (CallResult)->())
    throws
    -> Lnrpc_LightningSubscribeTransactionsCall {
      return try Lnrpc_LightningSubscribeTransactionsCall(channel).start(request:request, metadata:metadata, completion:completion)
  }
  /// Synchronous. Unary.
  internal func sendmany(_ request: Lnrpc_SendManyRequest)
    throws
    -> Lnrpc_SendManyResponse {
      return try Lnrpc_LightningSendManyCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func sendmany(_ request: Lnrpc_SendManyRequest,
                  completion: @escaping (Lnrpc_SendManyResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningSendManyCall {
      return try Lnrpc_LightningSendManyCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func newaddress(_ request: Lnrpc_NewAddressRequest)
    throws
    -> Lnrpc_NewAddressResponse {
      return try Lnrpc_LightningNewAddressCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func newaddress(_ request: Lnrpc_NewAddressRequest,
                  completion: @escaping (Lnrpc_NewAddressResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningNewAddressCall {
      return try Lnrpc_LightningNewAddressCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func newwitnessaddress(_ request: Lnrpc_NewWitnessAddressRequest)
    throws
    -> Lnrpc_NewAddressResponse {
      return try Lnrpc_LightningNewWitnessAddressCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func newwitnessaddress(_ request: Lnrpc_NewWitnessAddressRequest,
                  completion: @escaping (Lnrpc_NewAddressResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningNewWitnessAddressCall {
      return try Lnrpc_LightningNewWitnessAddressCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func signmessage(_ request: Lnrpc_SignMessageRequest)
    throws
    -> Lnrpc_SignMessageResponse {
      return try Lnrpc_LightningSignMessageCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func signmessage(_ request: Lnrpc_SignMessageRequest,
                  completion: @escaping (Lnrpc_SignMessageResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningSignMessageCall {
      return try Lnrpc_LightningSignMessageCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func verifymessage(_ request: Lnrpc_VerifyMessageRequest)
    throws
    -> Lnrpc_VerifyMessageResponse {
      return try Lnrpc_LightningVerifyMessageCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func verifymessage(_ request: Lnrpc_VerifyMessageRequest,
                  completion: @escaping (Lnrpc_VerifyMessageResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningVerifyMessageCall {
      return try Lnrpc_LightningVerifyMessageCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func connectpeer(_ request: Lnrpc_ConnectPeerRequest)
    throws
    -> Lnrpc_ConnectPeerResponse {
      return try Lnrpc_LightningConnectPeerCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func connectpeer(_ request: Lnrpc_ConnectPeerRequest,
                  completion: @escaping (Lnrpc_ConnectPeerResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningConnectPeerCall {
      return try Lnrpc_LightningConnectPeerCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func disconnectpeer(_ request: Lnrpc_DisconnectPeerRequest)
    throws
    -> Lnrpc_DisconnectPeerResponse {
      return try Lnrpc_LightningDisconnectPeerCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func disconnectpeer(_ request: Lnrpc_DisconnectPeerRequest,
                  completion: @escaping (Lnrpc_DisconnectPeerResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningDisconnectPeerCall {
      return try Lnrpc_LightningDisconnectPeerCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func listpeers(_ request: Lnrpc_ListPeersRequest)
    throws
    -> Lnrpc_ListPeersResponse {
      return try Lnrpc_LightningListPeersCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func listpeers(_ request: Lnrpc_ListPeersRequest,
                  completion: @escaping (Lnrpc_ListPeersResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningListPeersCall {
      return try Lnrpc_LightningListPeersCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func getinfo(_ request: Lnrpc_GetInfoRequest)
    throws
    -> Lnrpc_GetInfoResponse {
      return try Lnrpc_LightningGetInfoCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func getinfo(_ request: Lnrpc_GetInfoRequest,
                  completion: @escaping (Lnrpc_GetInfoResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningGetInfoCall {
      return try Lnrpc_LightningGetInfoCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func pendingchannels(_ request: Lnrpc_PendingChannelsRequest)
    throws
    -> Lnrpc_PendingChannelsResponse {
      return try Lnrpc_LightningPendingChannelsCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func pendingchannels(_ request: Lnrpc_PendingChannelsRequest,
                  completion: @escaping (Lnrpc_PendingChannelsResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningPendingChannelsCall {
      return try Lnrpc_LightningPendingChannelsCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func listchannels(_ request: Lnrpc_ListChannelsRequest)
    throws
    -> Lnrpc_ListChannelsResponse {
      return try Lnrpc_LightningListChannelsCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func listchannels(_ request: Lnrpc_ListChannelsRequest,
                  completion: @escaping (Lnrpc_ListChannelsResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningListChannelsCall {
      return try Lnrpc_LightningListChannelsCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func openchannelsync(_ request: Lnrpc_OpenChannelRequest)
    throws
    -> Lnrpc_ChannelPoint {
      return try Lnrpc_LightningOpenChannelSyncCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func openchannelsync(_ request: Lnrpc_OpenChannelRequest,
                  completion: @escaping (Lnrpc_ChannelPoint?, CallResult)->())
    throws
    -> Lnrpc_LightningOpenChannelSyncCall {
      return try Lnrpc_LightningOpenChannelSyncCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  internal func openchannel(_ request: Lnrpc_OpenChannelRequest, completion: @escaping (CallResult)->())
    throws
    -> Lnrpc_LightningOpenChannelCall {
      return try Lnrpc_LightningOpenChannelCall(channel).start(request:request, metadata:metadata, completion:completion)
  }
  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  internal func closechannel(_ request: Lnrpc_CloseChannelRequest, completion: @escaping (CallResult)->())
    throws
    -> Lnrpc_LightningCloseChannelCall {
      return try Lnrpc_LightningCloseChannelCall(channel).start(request:request, metadata:metadata, completion:completion)
  }
  /// Asynchronous. Bidirectional-streaming.
  /// Use methods on the returned object to stream messages,
  /// to wait for replies, and to close the connection.
  internal func sendpayment(completion: @escaping (CallResult)->())
    throws
    -> Lnrpc_LightningSendPaymentCall {
      return try Lnrpc_LightningSendPaymentCall(channel).start(metadata:metadata, completion:completion)
  }
  /// Synchronous. Unary.
  internal func sendpaymentsync(_ request: Lnrpc_SendRequest)
    throws
    -> Lnrpc_SendResponse {
      return try Lnrpc_LightningSendPaymentSyncCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func sendpaymentsync(_ request: Lnrpc_SendRequest,
                  completion: @escaping (Lnrpc_SendResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningSendPaymentSyncCall {
      return try Lnrpc_LightningSendPaymentSyncCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func addinvoice(_ request: Lnrpc_Invoice)
    throws
    -> Lnrpc_AddInvoiceResponse {
      return try Lnrpc_LightningAddInvoiceCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func addinvoice(_ request: Lnrpc_Invoice,
                  completion: @escaping (Lnrpc_AddInvoiceResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningAddInvoiceCall {
      return try Lnrpc_LightningAddInvoiceCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func listinvoices(_ request: Lnrpc_ListInvoiceRequest)
    throws
    -> Lnrpc_ListInvoiceResponse {
      return try Lnrpc_LightningListInvoicesCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func listinvoices(_ request: Lnrpc_ListInvoiceRequest,
                  completion: @escaping (Lnrpc_ListInvoiceResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningListInvoicesCall {
      return try Lnrpc_LightningListInvoicesCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func lookupinvoice(_ request: Lnrpc_PaymentHash)
    throws
    -> Lnrpc_Invoice {
      return try Lnrpc_LightningLookupInvoiceCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func lookupinvoice(_ request: Lnrpc_PaymentHash,
                  completion: @escaping (Lnrpc_Invoice?, CallResult)->())
    throws
    -> Lnrpc_LightningLookupInvoiceCall {
      return try Lnrpc_LightningLookupInvoiceCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  internal func subscribeinvoices(_ request: Lnrpc_InvoiceSubscription, completion: @escaping (CallResult)->())
    throws
    -> Lnrpc_LightningSubscribeInvoicesCall {
      return try Lnrpc_LightningSubscribeInvoicesCall(channel).start(request:request, metadata:metadata, completion:completion)
  }
  /// Synchronous. Unary.
  internal func decodepayreq(_ request: Lnrpc_PayReqString)
    throws
    -> Lnrpc_PayReq {
      return try Lnrpc_LightningDecodePayReqCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func decodepayreq(_ request: Lnrpc_PayReqString,
                  completion: @escaping (Lnrpc_PayReq?, CallResult)->())
    throws
    -> Lnrpc_LightningDecodePayReqCall {
      return try Lnrpc_LightningDecodePayReqCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func listpayments(_ request: Lnrpc_ListPaymentsRequest)
    throws
    -> Lnrpc_ListPaymentsResponse {
      return try Lnrpc_LightningListPaymentsCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func listpayments(_ request: Lnrpc_ListPaymentsRequest,
                  completion: @escaping (Lnrpc_ListPaymentsResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningListPaymentsCall {
      return try Lnrpc_LightningListPaymentsCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func deleteallpayments(_ request: Lnrpc_DeleteAllPaymentsRequest)
    throws
    -> Lnrpc_DeleteAllPaymentsResponse {
      return try Lnrpc_LightningDeleteAllPaymentsCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func deleteallpayments(_ request: Lnrpc_DeleteAllPaymentsRequest,
                  completion: @escaping (Lnrpc_DeleteAllPaymentsResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningDeleteAllPaymentsCall {
      return try Lnrpc_LightningDeleteAllPaymentsCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func describegraph(_ request: Lnrpc_ChannelGraphRequest)
    throws
    -> Lnrpc_ChannelGraph {
      return try Lnrpc_LightningDescribeGraphCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func describegraph(_ request: Lnrpc_ChannelGraphRequest,
                  completion: @escaping (Lnrpc_ChannelGraph?, CallResult)->())
    throws
    -> Lnrpc_LightningDescribeGraphCall {
      return try Lnrpc_LightningDescribeGraphCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func getchaninfo(_ request: Lnrpc_ChanInfoRequest)
    throws
    -> Lnrpc_ChannelEdge {
      return try Lnrpc_LightningGetChanInfoCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func getchaninfo(_ request: Lnrpc_ChanInfoRequest,
                  completion: @escaping (Lnrpc_ChannelEdge?, CallResult)->())
    throws
    -> Lnrpc_LightningGetChanInfoCall {
      return try Lnrpc_LightningGetChanInfoCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func getnodeinfo(_ request: Lnrpc_NodeInfoRequest)
    throws
    -> Lnrpc_NodeInfo {
      return try Lnrpc_LightningGetNodeInfoCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func getnodeinfo(_ request: Lnrpc_NodeInfoRequest,
                  completion: @escaping (Lnrpc_NodeInfo?, CallResult)->())
    throws
    -> Lnrpc_LightningGetNodeInfoCall {
      return try Lnrpc_LightningGetNodeInfoCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func queryroutes(_ request: Lnrpc_QueryRoutesRequest)
    throws
    -> Lnrpc_QueryRoutesResponse {
      return try Lnrpc_LightningQueryRoutesCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func queryroutes(_ request: Lnrpc_QueryRoutesRequest,
                  completion: @escaping (Lnrpc_QueryRoutesResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningQueryRoutesCall {
      return try Lnrpc_LightningQueryRoutesCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func getnetworkinfo(_ request: Lnrpc_NetworkInfoRequest)
    throws
    -> Lnrpc_NetworkInfo {
      return try Lnrpc_LightningGetNetworkInfoCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func getnetworkinfo(_ request: Lnrpc_NetworkInfoRequest,
                  completion: @escaping (Lnrpc_NetworkInfo?, CallResult)->())
    throws
    -> Lnrpc_LightningGetNetworkInfoCall {
      return try Lnrpc_LightningGetNetworkInfoCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func stopdaemon(_ request: Lnrpc_StopRequest)
    throws
    -> Lnrpc_StopResponse {
      return try Lnrpc_LightningStopDaemonCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func stopdaemon(_ request: Lnrpc_StopRequest,
                  completion: @escaping (Lnrpc_StopResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningStopDaemonCall {
      return try Lnrpc_LightningStopDaemonCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  internal func subscribechannelgraph(_ request: Lnrpc_GraphTopologySubscription, completion: @escaping (CallResult)->())
    throws
    -> Lnrpc_LightningSubscribeChannelGraphCall {
      return try Lnrpc_LightningSubscribeChannelGraphCall(channel).start(request:request, metadata:metadata, completion:completion)
  }
  /// Synchronous. Unary.
  internal func debuglevel(_ request: Lnrpc_DebugLevelRequest)
    throws
    -> Lnrpc_DebugLevelResponse {
      return try Lnrpc_LightningDebugLevelCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func debuglevel(_ request: Lnrpc_DebugLevelRequest,
                  completion: @escaping (Lnrpc_DebugLevelResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningDebugLevelCall {
      return try Lnrpc_LightningDebugLevelCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func feereport(_ request: Lnrpc_FeeReportRequest)
    throws
    -> Lnrpc_FeeReportResponse {
      return try Lnrpc_LightningFeeReportCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func feereport(_ request: Lnrpc_FeeReportRequest,
                  completion: @escaping (Lnrpc_FeeReportResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningFeeReportCall {
      return try Lnrpc_LightningFeeReportCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
  /// Synchronous. Unary.
  internal func updatechannelpolicy(_ request: Lnrpc_PolicyUpdateRequest)
    throws
    -> Lnrpc_PolicyUpdateResponse {
      return try Lnrpc_LightningUpdateChannelPolicyCall(channel).run(request:request, metadata:metadata)
  }
  /// Asynchronous. Unary.
  internal func updatechannelpolicy(_ request: Lnrpc_PolicyUpdateRequest,
                  completion: @escaping (Lnrpc_PolicyUpdateResponse?, CallResult)->())
    throws
    -> Lnrpc_LightningUpdateChannelPolicyCall {
      return try Lnrpc_LightningUpdateChannelPolicyCall(channel).start(request:request,
                                                 metadata:metadata,
                                                 completion:completion)
  }
}


/// Type for errors thrown from generated server code.
internal enum Lnrpc_WalletUnlockerServerError : Error {
  case endOfStream
}

/// To build a server, implement a class that conforms to this protocol.
internal protocol Lnrpc_WalletUnlockerProvider {
  func createwallet(request : Lnrpc_CreateWalletRequest, session : Lnrpc_WalletUnlockerCreateWalletSession) throws -> Lnrpc_CreateWalletResponse
  func unlockwallet(request : Lnrpc_UnlockWalletRequest, session : Lnrpc_WalletUnlockerUnlockWalletSession) throws -> Lnrpc_UnlockWalletResponse
}

/// Common properties available in each service session.
internal final class Lnrpc_WalletUnlockerSession {
  fileprivate var handler : gRPC.Handler
  internal var requestMetadata : Metadata { return handler.requestMetadata }

  internal var statusCode : StatusCode = .ok
  internal var statusMessage : String = "OK"
  internal var initialMetadata : Metadata = Metadata()
  internal var trailingMetadata : Metadata = Metadata()

  fileprivate init(handler:gRPC.Handler) {
    self.handler = handler
  }
}

// CreateWallet (Unary)
internal final class Lnrpc_WalletUnlockerCreateWalletSession : Lnrpc_WalletUnlockerSession {
  private var provider : Lnrpc_WalletUnlockerProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_WalletUnlockerProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_CreateWalletRequest(serializedData:requestData)
        let replyMessage = try self.provider.createwallet(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// UnlockWallet (Unary)
internal final class Lnrpc_WalletUnlockerUnlockWalletSession : Lnrpc_WalletUnlockerSession {
  private var provider : Lnrpc_WalletUnlockerProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_WalletUnlockerProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_UnlockWalletRequest(serializedData:requestData)
        let replyMessage = try self.provider.unlockwallet(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}


/// Main server for generated service
internal final class Lnrpc_WalletUnlockerServer {
  private var address: String
  private var server: gRPC.Server
  private var provider: Lnrpc_WalletUnlockerProvider?

  /// Create a server that accepts insecure connections.
  internal init(address:String,
              provider:Lnrpc_WalletUnlockerProvider) {
    gRPC.initialize()
    self.address = address
    self.provider = provider
    self.server = gRPC.Server(address:address)
  }

  /// Create a server that accepts secure connections.
  internal init?(address:String,
               certificateURL:URL,
               keyURL:URL,
               provider:Lnrpc_WalletUnlockerProvider) {
    gRPC.initialize()
    self.address = address
    self.provider = provider
    guard
      let certificate = try? String(contentsOf: certificateURL, encoding: .utf8),
      let key = try? String(contentsOf: keyURL, encoding: .utf8)
      else {
        return nil
    }
    self.server = gRPC.Server(address:address, key:key, certs:certificate)
  }

  /// Start the server.
  internal func start(queue:DispatchQueue = DispatchQueue.global()) {
    guard let provider = self.provider else {
      fatalError() // the server requires a provider
    }
    server.run {(handler) in
      print("Server received request to " + handler.host
        + " calling " + handler.method
        + " from " + handler.caller
        + " with " + String(describing:handler.requestMetadata) )

      do {
        switch handler.method {
        case "/lnrpc.WalletUnlocker/CreateWallet":
          try Lnrpc_WalletUnlockerCreateWalletSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.WalletUnlocker/UnlockWallet":
          try Lnrpc_WalletUnlockerUnlockWalletSession(handler:handler, provider:provider).run(queue:queue)
        default:
          // handle unknown requests
          try handler.receiveMessage(initialMetadata:Metadata()) {(requestData) in
            try handler.sendResponse(statusCode:.unimplemented,
                                     statusMessage:"unknown method " + handler.method,
                                     trailingMetadata:Metadata())
          }
        }
      } catch (let error) {
        print("Server error: \(error)")
      }
    }
  }
}

/// Type for errors thrown from generated server code.
internal enum Lnrpc_LightningServerError : Error {
  case endOfStream
}

/// To build a server, implement a class that conforms to this protocol.
internal protocol Lnrpc_LightningProvider {
  func walletbalance(request : Lnrpc_WalletBalanceRequest, session : Lnrpc_LightningWalletBalanceSession) throws -> Lnrpc_WalletBalanceResponse
  func channelbalance(request : Lnrpc_ChannelBalanceRequest, session : Lnrpc_LightningChannelBalanceSession) throws -> Lnrpc_ChannelBalanceResponse
  func gettransactions(request : Lnrpc_GetTransactionsRequest, session : Lnrpc_LightningGetTransactionsSession) throws -> Lnrpc_TransactionDetails
  func sendcoins(request : Lnrpc_SendCoinsRequest, session : Lnrpc_LightningSendCoinsSession) throws -> Lnrpc_SendCoinsResponse
  func subscribetransactions(request : Lnrpc_GetTransactionsRequest, session : Lnrpc_LightningSubscribeTransactionsSession) throws
  func sendmany(request : Lnrpc_SendManyRequest, session : Lnrpc_LightningSendManySession) throws -> Lnrpc_SendManyResponse
  func newaddress(request : Lnrpc_NewAddressRequest, session : Lnrpc_LightningNewAddressSession) throws -> Lnrpc_NewAddressResponse
  func newwitnessaddress(request : Lnrpc_NewWitnessAddressRequest, session : Lnrpc_LightningNewWitnessAddressSession) throws -> Lnrpc_NewAddressResponse
  func signmessage(request : Lnrpc_SignMessageRequest, session : Lnrpc_LightningSignMessageSession) throws -> Lnrpc_SignMessageResponse
  func verifymessage(request : Lnrpc_VerifyMessageRequest, session : Lnrpc_LightningVerifyMessageSession) throws -> Lnrpc_VerifyMessageResponse
  func connectpeer(request : Lnrpc_ConnectPeerRequest, session : Lnrpc_LightningConnectPeerSession) throws -> Lnrpc_ConnectPeerResponse
  func disconnectpeer(request : Lnrpc_DisconnectPeerRequest, session : Lnrpc_LightningDisconnectPeerSession) throws -> Lnrpc_DisconnectPeerResponse
  func listpeers(request : Lnrpc_ListPeersRequest, session : Lnrpc_LightningListPeersSession) throws -> Lnrpc_ListPeersResponse
  func getinfo(request : Lnrpc_GetInfoRequest, session : Lnrpc_LightningGetInfoSession) throws -> Lnrpc_GetInfoResponse
  func pendingchannels(request : Lnrpc_PendingChannelsRequest, session : Lnrpc_LightningPendingChannelsSession) throws -> Lnrpc_PendingChannelsResponse
  func listchannels(request : Lnrpc_ListChannelsRequest, session : Lnrpc_LightningListChannelsSession) throws -> Lnrpc_ListChannelsResponse
  func openchannelsync(request : Lnrpc_OpenChannelRequest, session : Lnrpc_LightningOpenChannelSyncSession) throws -> Lnrpc_ChannelPoint
  func openchannel(request : Lnrpc_OpenChannelRequest, session : Lnrpc_LightningOpenChannelSession) throws
  func closechannel(request : Lnrpc_CloseChannelRequest, session : Lnrpc_LightningCloseChannelSession) throws
  func sendpayment(session : Lnrpc_LightningSendPaymentSession) throws
  func sendpaymentsync(request : Lnrpc_SendRequest, session : Lnrpc_LightningSendPaymentSyncSession) throws -> Lnrpc_SendResponse
  func addinvoice(request : Lnrpc_Invoice, session : Lnrpc_LightningAddInvoiceSession) throws -> Lnrpc_AddInvoiceResponse
  func listinvoices(request : Lnrpc_ListInvoiceRequest, session : Lnrpc_LightningListInvoicesSession) throws -> Lnrpc_ListInvoiceResponse
  func lookupinvoice(request : Lnrpc_PaymentHash, session : Lnrpc_LightningLookupInvoiceSession) throws -> Lnrpc_Invoice
  func subscribeinvoices(request : Lnrpc_InvoiceSubscription, session : Lnrpc_LightningSubscribeInvoicesSession) throws
  func decodepayreq(request : Lnrpc_PayReqString, session : Lnrpc_LightningDecodePayReqSession) throws -> Lnrpc_PayReq
  func listpayments(request : Lnrpc_ListPaymentsRequest, session : Lnrpc_LightningListPaymentsSession) throws -> Lnrpc_ListPaymentsResponse
  func deleteallpayments(request : Lnrpc_DeleteAllPaymentsRequest, session : Lnrpc_LightningDeleteAllPaymentsSession) throws -> Lnrpc_DeleteAllPaymentsResponse
  func describegraph(request : Lnrpc_ChannelGraphRequest, session : Lnrpc_LightningDescribeGraphSession) throws -> Lnrpc_ChannelGraph
  func getchaninfo(request : Lnrpc_ChanInfoRequest, session : Lnrpc_LightningGetChanInfoSession) throws -> Lnrpc_ChannelEdge
  func getnodeinfo(request : Lnrpc_NodeInfoRequest, session : Lnrpc_LightningGetNodeInfoSession) throws -> Lnrpc_NodeInfo
  func queryroutes(request : Lnrpc_QueryRoutesRequest, session : Lnrpc_LightningQueryRoutesSession) throws -> Lnrpc_QueryRoutesResponse
  func getnetworkinfo(request : Lnrpc_NetworkInfoRequest, session : Lnrpc_LightningGetNetworkInfoSession) throws -> Lnrpc_NetworkInfo
  func stopdaemon(request : Lnrpc_StopRequest, session : Lnrpc_LightningStopDaemonSession) throws -> Lnrpc_StopResponse
  func subscribechannelgraph(request : Lnrpc_GraphTopologySubscription, session : Lnrpc_LightningSubscribeChannelGraphSession) throws
  func debuglevel(request : Lnrpc_DebugLevelRequest, session : Lnrpc_LightningDebugLevelSession) throws -> Lnrpc_DebugLevelResponse
  func feereport(request : Lnrpc_FeeReportRequest, session : Lnrpc_LightningFeeReportSession) throws -> Lnrpc_FeeReportResponse
  func updatechannelpolicy(request : Lnrpc_PolicyUpdateRequest, session : Lnrpc_LightningUpdateChannelPolicySession) throws -> Lnrpc_PolicyUpdateResponse
}

/// Common properties available in each service session.
internal final class Lnrpc_LightningSession {
  fileprivate var handler : gRPC.Handler
  internal var requestMetadata : Metadata { return handler.requestMetadata }

  internal var statusCode : StatusCode = .ok
  internal var statusMessage : String = "OK"
  internal var initialMetadata : Metadata = Metadata()
  internal var trailingMetadata : Metadata = Metadata()

  fileprivate init(handler:gRPC.Handler) {
    self.handler = handler
  }
}

// WalletBalance (Unary)
internal final class Lnrpc_LightningWalletBalanceSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_WalletBalanceRequest(serializedData:requestData)
        let replyMessage = try self.provider.walletbalance(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// ChannelBalance (Unary)
internal final class Lnrpc_LightningChannelBalanceSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_ChannelBalanceRequest(serializedData:requestData)
        let replyMessage = try self.provider.channelbalance(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// GetTransactions (Unary)
internal final class Lnrpc_LightningGetTransactionsSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_GetTransactionsRequest(serializedData:requestData)
        let replyMessage = try self.provider.gettransactions(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// SendCoins (Unary)
internal final class Lnrpc_LightningSendCoinsSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_SendCoinsRequest(serializedData:requestData)
        let replyMessage = try self.provider.sendcoins(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// SubscribeTransactions (Server Streaming)
internal final class Lnrpc_LightningSubscribeTransactionsSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Send a message. Nonblocking.
  internal func send(_ response: Lnrpc_Transaction, completion: @escaping ()->()) throws {
    try handler.sendResponse(message:response.serializedData()) {completion()}
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try self.handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        do {
          let requestMessage = try Lnrpc_GetTransactionsRequest(serializedData:requestData)
          // to keep providers from blocking the server thread,
          // we dispatch them to another queue.
          queue.async {
            do {
              try self.provider.subscribetransactions(request:requestMessage, session: self)
              try self.handler.sendStatus(statusCode:self.statusCode,
                                          statusMessage:self.statusMessage,
                                          trailingMetadata:self.trailingMetadata,
                                          completion:{})
            } catch (let error) {
              print("error: \(error)")
            }
          }
        } catch (let error) {
          print("error: \(error)")
        }
      }
    }
  }
}

// SendMany (Unary)
internal final class Lnrpc_LightningSendManySession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_SendManyRequest(serializedData:requestData)
        let replyMessage = try self.provider.sendmany(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// NewAddress (Unary)
internal final class Lnrpc_LightningNewAddressSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_NewAddressRequest(serializedData:requestData)
        let replyMessage = try self.provider.newaddress(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// NewWitnessAddress (Unary)
internal final class Lnrpc_LightningNewWitnessAddressSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_NewWitnessAddressRequest(serializedData:requestData)
        let replyMessage = try self.provider.newwitnessaddress(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// SignMessage (Unary)
internal final class Lnrpc_LightningSignMessageSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_SignMessageRequest(serializedData:requestData)
        let replyMessage = try self.provider.signmessage(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// VerifyMessage (Unary)
internal final class Lnrpc_LightningVerifyMessageSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_VerifyMessageRequest(serializedData:requestData)
        let replyMessage = try self.provider.verifymessage(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// ConnectPeer (Unary)
internal final class Lnrpc_LightningConnectPeerSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_ConnectPeerRequest(serializedData:requestData)
        let replyMessage = try self.provider.connectpeer(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// DisconnectPeer (Unary)
internal final class Lnrpc_LightningDisconnectPeerSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_DisconnectPeerRequest(serializedData:requestData)
        let replyMessage = try self.provider.disconnectpeer(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// ListPeers (Unary)
internal final class Lnrpc_LightningListPeersSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_ListPeersRequest(serializedData:requestData)
        let replyMessage = try self.provider.listpeers(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// GetInfo (Unary)
internal final class Lnrpc_LightningGetInfoSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_GetInfoRequest(serializedData:requestData)
        let replyMessage = try self.provider.getinfo(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// PendingChannels (Unary)
internal final class Lnrpc_LightningPendingChannelsSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_PendingChannelsRequest(serializedData:requestData)
        let replyMessage = try self.provider.pendingchannels(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// ListChannels (Unary)
internal final class Lnrpc_LightningListChannelsSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_ListChannelsRequest(serializedData:requestData)
        let replyMessage = try self.provider.listchannels(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// OpenChannelSync (Unary)
internal final class Lnrpc_LightningOpenChannelSyncSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_OpenChannelRequest(serializedData:requestData)
        let replyMessage = try self.provider.openchannelsync(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// OpenChannel (Server Streaming)
internal final class Lnrpc_LightningOpenChannelSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Send a message. Nonblocking.
  internal func send(_ response: Lnrpc_OpenStatusUpdate, completion: @escaping ()->()) throws {
    try handler.sendResponse(message:response.serializedData()) {completion()}
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try self.handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        do {
          let requestMessage = try Lnrpc_OpenChannelRequest(serializedData:requestData)
          // to keep providers from blocking the server thread,
          // we dispatch them to another queue.
          queue.async {
            do {
              try self.provider.openchannel(request:requestMessage, session: self)
              try self.handler.sendStatus(statusCode:self.statusCode,
                                          statusMessage:self.statusMessage,
                                          trailingMetadata:self.trailingMetadata,
                                          completion:{})
            } catch (let error) {
              print("error: \(error)")
            }
          }
        } catch (let error) {
          print("error: \(error)")
        }
      }
    }
  }
}

// CloseChannel (Server Streaming)
internal final class Lnrpc_LightningCloseChannelSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Send a message. Nonblocking.
  internal func send(_ response: Lnrpc_CloseStatusUpdate, completion: @escaping ()->()) throws {
    try handler.sendResponse(message:response.serializedData()) {completion()}
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try self.handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        do {
          let requestMessage = try Lnrpc_CloseChannelRequest(serializedData:requestData)
          // to keep providers from blocking the server thread,
          // we dispatch them to another queue.
          queue.async {
            do {
              try self.provider.closechannel(request:requestMessage, session: self)
              try self.handler.sendStatus(statusCode:self.statusCode,
                                          statusMessage:self.statusMessage,
                                          trailingMetadata:self.trailingMetadata,
                                          completion:{})
            } catch (let error) {
              print("error: \(error)")
            }
          }
        } catch (let error) {
          print("error: \(error)")
        }
      }
    }
  }
}

// SendPayment (Bidirectional Streaming)
internal final class Lnrpc_LightningSendPaymentSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Receive a message. Blocks until a message is received or the client closes the connection.
  internal func receive() throws -> Lnrpc_SendRequest {
    let sem = DispatchSemaphore(value: 0)
    var requestMessage : Lnrpc_SendRequest?
    try self.handler.receiveMessage() {(requestData) in
      if let requestData = requestData {
        do {
          requestMessage = try Lnrpc_SendRequest(serializedData:requestData)
        } catch (let error) {
          print("error \(error)")
        }
      }
      sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
    if let requestMessage = requestMessage {
      return requestMessage
    } else {
      throw Lnrpc_LightningServerError.endOfStream
    }
  }

  /// Send a message. Nonblocking.
  internal func send(_ response: Lnrpc_SendResponse, completion: @escaping ()->()) throws {
    try handler.sendResponse(message:response.serializedData()) {completion()}
  }

  /// Close a connection. Blocks until the connection is closed.
  internal func close() throws {
    let sem = DispatchSemaphore(value: 0)
    try self.handler.sendStatus(statusCode:self.statusCode,
                                statusMessage:self.statusMessage,
                                trailingMetadata:self.trailingMetadata) {
                                  sem.signal()
    }
    _ = sem.wait(timeout: DispatchTime.distantFuture)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try self.handler.sendMetadata(initialMetadata:initialMetadata) {
      queue.async {
        do {
          try self.provider.sendpayment(session:self)
        } catch (let error) {
          print("error \(error)")
        }
      }
    }
  }
}

// SendPaymentSync (Unary)
internal final class Lnrpc_LightningSendPaymentSyncSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_SendRequest(serializedData:requestData)
        let replyMessage = try self.provider.sendpaymentsync(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// AddInvoice (Unary)
internal final class Lnrpc_LightningAddInvoiceSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_Invoice(serializedData:requestData)
        let replyMessage = try self.provider.addinvoice(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// ListInvoices (Unary)
internal final class Lnrpc_LightningListInvoicesSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_ListInvoiceRequest(serializedData:requestData)
        let replyMessage = try self.provider.listinvoices(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// LookupInvoice (Unary)
internal final class Lnrpc_LightningLookupInvoiceSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_PaymentHash(serializedData:requestData)
        let replyMessage = try self.provider.lookupinvoice(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// SubscribeInvoices (Server Streaming)
internal final class Lnrpc_LightningSubscribeInvoicesSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Send a message. Nonblocking.
  internal func send(_ response: Lnrpc_Invoice, completion: @escaping ()->()) throws {
    try handler.sendResponse(message:response.serializedData()) {completion()}
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try self.handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        do {
          let requestMessage = try Lnrpc_InvoiceSubscription(serializedData:requestData)
          // to keep providers from blocking the server thread,
          // we dispatch them to another queue.
          queue.async {
            do {
              try self.provider.subscribeinvoices(request:requestMessage, session: self)
              try self.handler.sendStatus(statusCode:self.statusCode,
                                          statusMessage:self.statusMessage,
                                          trailingMetadata:self.trailingMetadata,
                                          completion:{})
            } catch (let error) {
              print("error: \(error)")
            }
          }
        } catch (let error) {
          print("error: \(error)")
        }
      }
    }
  }
}

// DecodePayReq (Unary)
internal final class Lnrpc_LightningDecodePayReqSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_PayReqString(serializedData:requestData)
        let replyMessage = try self.provider.decodepayreq(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// ListPayments (Unary)
internal final class Lnrpc_LightningListPaymentsSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_ListPaymentsRequest(serializedData:requestData)
        let replyMessage = try self.provider.listpayments(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// DeleteAllPayments (Unary)
internal final class Lnrpc_LightningDeleteAllPaymentsSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_DeleteAllPaymentsRequest(serializedData:requestData)
        let replyMessage = try self.provider.deleteallpayments(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// DescribeGraph (Unary)
internal final class Lnrpc_LightningDescribeGraphSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_ChannelGraphRequest(serializedData:requestData)
        let replyMessage = try self.provider.describegraph(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// GetChanInfo (Unary)
internal final class Lnrpc_LightningGetChanInfoSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_ChanInfoRequest(serializedData:requestData)
        let replyMessage = try self.provider.getchaninfo(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// GetNodeInfo (Unary)
internal final class Lnrpc_LightningGetNodeInfoSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_NodeInfoRequest(serializedData:requestData)
        let replyMessage = try self.provider.getnodeinfo(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// QueryRoutes (Unary)
internal final class Lnrpc_LightningQueryRoutesSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_QueryRoutesRequest(serializedData:requestData)
        let replyMessage = try self.provider.queryroutes(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// GetNetworkInfo (Unary)
internal final class Lnrpc_LightningGetNetworkInfoSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_NetworkInfoRequest(serializedData:requestData)
        let replyMessage = try self.provider.getnetworkinfo(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// StopDaemon (Unary)
internal final class Lnrpc_LightningStopDaemonSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_StopRequest(serializedData:requestData)
        let replyMessage = try self.provider.stopdaemon(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// SubscribeChannelGraph (Server Streaming)
internal final class Lnrpc_LightningSubscribeChannelGraphSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Send a message. Nonblocking.
  internal func send(_ response: Lnrpc_GraphTopologyUpdate, completion: @escaping ()->()) throws {
    try handler.sendResponse(message:response.serializedData()) {completion()}
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try self.handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        do {
          let requestMessage = try Lnrpc_GraphTopologySubscription(serializedData:requestData)
          // to keep providers from blocking the server thread,
          // we dispatch them to another queue.
          queue.async {
            do {
              try self.provider.subscribechannelgraph(request:requestMessage, session: self)
              try self.handler.sendStatus(statusCode:self.statusCode,
                                          statusMessage:self.statusMessage,
                                          trailingMetadata:self.trailingMetadata,
                                          completion:{})
            } catch (let error) {
              print("error: \(error)")
            }
          }
        } catch (let error) {
          print("error: \(error)")
        }
      }
    }
  }
}

// DebugLevel (Unary)
internal final class Lnrpc_LightningDebugLevelSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_DebugLevelRequest(serializedData:requestData)
        let replyMessage = try self.provider.debuglevel(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// FeeReport (Unary)
internal final class Lnrpc_LightningFeeReportSession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_FeeReportRequest(serializedData:requestData)
        let replyMessage = try self.provider.feereport(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}

// UpdateChannelPolicy (Unary)
internal final class Lnrpc_LightningUpdateChannelPolicySession : Lnrpc_LightningSession {
  private var provider : Lnrpc_LightningProvider

  /// Create a session.
  fileprivate init(handler:gRPC.Handler, provider: Lnrpc_LightningProvider) {
    self.provider = provider
    super.init(handler:handler)
  }

  /// Run the session. Internal.
  fileprivate func run(queue:DispatchQueue) throws {
    try handler.receiveMessage(initialMetadata:initialMetadata) {(requestData) in
      if let requestData = requestData {
        let requestMessage = try Lnrpc_PolicyUpdateRequest(serializedData:requestData)
        let replyMessage = try self.provider.updatechannelpolicy(request:requestMessage, session: self)
        try self.handler.sendResponse(message:replyMessage.serializedData(),
                                      statusCode:self.statusCode,
                                      statusMessage:self.statusMessage,
                                      trailingMetadata:self.trailingMetadata)
      }
    }
  }
}


/// Main server for generated service
internal final class Lnrpc_LightningServer {
  private var address: String
  private var server: gRPC.Server
  private var provider: Lnrpc_LightningProvider?

  /// Create a server that accepts insecure connections.
  internal init(address:String,
              provider:Lnrpc_LightningProvider) {
    gRPC.initialize()
    self.address = address
    self.provider = provider
    self.server = gRPC.Server(address:address)
  }

  /// Create a server that accepts secure connections.
  internal init?(address:String,
               certificateURL:URL,
               keyURL:URL,
               provider:Lnrpc_LightningProvider) {
    gRPC.initialize()
    self.address = address
    self.provider = provider
    guard
      let certificate = try? String(contentsOf: certificateURL, encoding: .utf8),
      let key = try? String(contentsOf: keyURL, encoding: .utf8)
      else {
        return nil
    }
    self.server = gRPC.Server(address:address, key:key, certs:certificate)
  }

  /// Start the server.
  internal func start(queue:DispatchQueue = DispatchQueue.global()) {
    guard let provider = self.provider else {
      fatalError() // the server requires a provider
    }
    server.run {(handler) in
      print("Server received request to " + handler.host
        + " calling " + handler.method
        + " from " + handler.caller
        + " with " + String(describing:handler.requestMetadata) )

      do {
        switch handler.method {
        case "/lnrpc.Lightning/WalletBalance":
          try Lnrpc_LightningWalletBalanceSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/ChannelBalance":
          try Lnrpc_LightningChannelBalanceSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/GetTransactions":
          try Lnrpc_LightningGetTransactionsSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/SendCoins":
          try Lnrpc_LightningSendCoinsSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/SubscribeTransactions":
          try Lnrpc_LightningSubscribeTransactionsSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/SendMany":
          try Lnrpc_LightningSendManySession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/NewAddress":
          try Lnrpc_LightningNewAddressSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/NewWitnessAddress":
          try Lnrpc_LightningNewWitnessAddressSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/SignMessage":
          try Lnrpc_LightningSignMessageSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/VerifyMessage":
          try Lnrpc_LightningVerifyMessageSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/ConnectPeer":
          try Lnrpc_LightningConnectPeerSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/DisconnectPeer":
          try Lnrpc_LightningDisconnectPeerSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/ListPeers":
          try Lnrpc_LightningListPeersSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/GetInfo":
          try Lnrpc_LightningGetInfoSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/PendingChannels":
          try Lnrpc_LightningPendingChannelsSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/ListChannels":
          try Lnrpc_LightningListChannelsSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/OpenChannelSync":
          try Lnrpc_LightningOpenChannelSyncSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/OpenChannel":
          try Lnrpc_LightningOpenChannelSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/CloseChannel":
          try Lnrpc_LightningCloseChannelSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/SendPayment":
          try Lnrpc_LightningSendPaymentSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/SendPaymentSync":
          try Lnrpc_LightningSendPaymentSyncSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/AddInvoice":
          try Lnrpc_LightningAddInvoiceSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/ListInvoices":
          try Lnrpc_LightningListInvoicesSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/LookupInvoice":
          try Lnrpc_LightningLookupInvoiceSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/SubscribeInvoices":
          try Lnrpc_LightningSubscribeInvoicesSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/DecodePayReq":
          try Lnrpc_LightningDecodePayReqSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/ListPayments":
          try Lnrpc_LightningListPaymentsSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/DeleteAllPayments":
          try Lnrpc_LightningDeleteAllPaymentsSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/DescribeGraph":
          try Lnrpc_LightningDescribeGraphSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/GetChanInfo":
          try Lnrpc_LightningGetChanInfoSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/GetNodeInfo":
          try Lnrpc_LightningGetNodeInfoSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/QueryRoutes":
          try Lnrpc_LightningQueryRoutesSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/GetNetworkInfo":
          try Lnrpc_LightningGetNetworkInfoSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/StopDaemon":
          try Lnrpc_LightningStopDaemonSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/SubscribeChannelGraph":
          try Lnrpc_LightningSubscribeChannelGraphSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/DebugLevel":
          try Lnrpc_LightningDebugLevelSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/FeeReport":
          try Lnrpc_LightningFeeReportSession(handler:handler, provider:provider).run(queue:queue)
        case "/lnrpc.Lightning/UpdateChannelPolicy":
          try Lnrpc_LightningUpdateChannelPolicySession(handler:handler, provider:provider).run(queue:queue)
        default:
          // handle unknown requests
          try handler.receiveMessage(initialMetadata:Metadata()) {(requestData) in
            try handler.sendResponse(statusCode:.unimplemented,
                                     statusMessage:"unknown method " + handler.method,
                                     trailingMetadata:Metadata())
          }
        }
      } catch (let error) {
        print("Server error: \(error)")
      }
    }
  }
}

